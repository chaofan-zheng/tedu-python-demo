"""
    复习 - Python 高级
    1. 包与模块
        (1). 导入方式
            "我过去":import 路径.模块名
            "你过来":from 路径.模块名 import 成员
        (2). 路径：建议采用绝对路径
            从根目录(在pycharm中标蓝的文件夹)开始写
        (3). 导入是否成功的唯一标准：
            导入路径 + sys.path = 真实路径
    2. 异常处理
        (1)现象:程序不再向下执行,而是不断向上返回
        (2)处理:让错误(向上)流程恢复正常(向下)流程
        (3)价值:保障程序按照既定流程执行
        (4)原则:就近原则(早发现早治疗)
        (5)手段：
            try:
                可能出错的代码
            except Exception:
                处理逻辑

            try:
                可能出错的代码
            except: # 与上面写法等同
                处理逻辑


    3. 生成器
        (1)生成器函数:
            def 函数名():
                ...
                yield 数据
                ...
        (2)生成器表达式
            (变量 for 变量 in 可迭代对象 if 条件)
        (3)使用方式：for循环(不断调用__next__函数)
        (4)价值：推算数据,而不是准备好所有结果.
                循环一次,计算一次,返回一次
        (5)适用性：函数返回多个结果使用生成器
            传统思想：创建容器存储结果
                优点：操作灵活(索引,切片,反复,修改)
                缺点：占用内存
            生成器思想：推算数据,不存储数据
                优点：节省内存
                缺点：只能从头到尾读取一次
                解决：将生成器转换为容器 tuple(生成器)
        (6)面试题：请简述生成器与迭代器的关系.
            答：通过yield关键字将生成器函数代码分解为多个__next__函数
               为了客户端代码循环一次,调用一次,返回一次数据，
               不使用容器存储所有结果,节省内存.

    4.函数式编程:
        (1) 三大编程范式
            面向过程：考虑问题从步骤的角度出发
                例如：排序问题
                    a.取数据
                    b.作比较
                    c.找更大或更小
                    d.交换
            面向对象：考虑问题从对象的角度出发
                例如：MVC
                    Mode负责抽象数据
                    View负责界面逻辑
                    Controller负责核心逻辑
            函数式编程：参数或者返回值是函数
                例如：IterableHelper类中高阶函数,
                     参数是函数,就可以传递条件或者处理逻辑

    5. 装饰器:不修改旧功能调用与定义,而增加新功能
        def 装饰器(func):
            def 包裹函数():
                新功能
                func()
            return 包裹函数

        @装饰器  # 旧功能 = 装饰器(旧功能)
        def 旧功能():
            pass

        旧功能()
"""

"""
class generator:# 生成器
    def __iter__(self): # 可迭代对象
        return self
    
    def __next__(self): # 迭代器对象
        函数体
        return 数据
"""


def func01():
    for number in range(100):
        if number % 2 == 0:
            yield number


# 调用函数不执行函数体,返回生成器对象
res = func01()
# yield将函数分解为多个__next__函数,所以使用for驱动
for item in res:
    print(item)
